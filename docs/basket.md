# Basket – Корзинка Фруктов

Корзинка Фруктов, флагов или пирожков — не важно как называть, в общем некоторых сущностей, — позволяет хранить все системные для класса флаги, режимы, перечисления и компактные значения в одном поле данных, которое попадает в регистр процессора целиком. Это просто ещё один подход к разработке классов, который некоторым разработчикам может прийтись по душе. Такой подход компактнее, быстрее и нагляднее, позволяет лучше воспринимать класс как конечный автомат с множеством встроенных переключателей. Однако данный подход, как и всё в нашей жизни, конечно же подойдёт и понравится не всем — всё зависит от взглядов, ценностей и мировозрения разработчика.

Хранение примитивных данных в одном поле ускоряет как запись, так и проверку состояния множества значений, т.к. они обрабатываются в одном регистре. Это также сокращает объём занимаемой объектом памяти. Компактный размер объекта особенно имеет смысл, когда таких обрабатываемых объектов много. Так большее число объектов поместится в кеш память процессора, и они меньше будут грузиться из оперативной памяти. Оперативная память и особенно её шина для процессора работают довольно медленно, шина памяти часто становится узким местом в процессе доставки данных к центральному процессору для обработки и обратно. Также компактных объектов больше уместится в кеш линию, что также ускорит доставку данных к процессору.

## Использование

### Визуализация воображения

Предлагаю такое визуальное представление работы Корзинки Фруктов. Саму корзинку можно представлять себе в виде собственно корзинки или абстрактной коробки. Значения корзинки представим в виде небольших мячиков или шаров, как теннисных или бильардных, можно меньше или в виде фруктов, если так комфортнее. Сами по себе шарики все разные, как следствие, в корзинке нет одинаковых шаров, но в абстрактном представлении шарики могут быть в нескольких экземплярах (ниже подробнее). Отличаться они могут по цвету, надписям, форме, как кому удобнее. При разработке, лично я представляю их шарами, но называю, например: «кладём флаг инициализации в корзинку» — это воображаемый шар, например голубого цвета, которым я символизирую состояние инициализации. Сейчас предположим, что у нас есть семь шаров покрашенных в семь цветов радуги, и отличаются они только цветом.

Итак представим, перед нами есть поверхность стола, на ней в ряд лежат семь разноцветных шаров, а чуть за ними пустая коробка, которую будем условно называть корзинкой. Мы выполнили какую-то операцию и хотим зафиксировать её для себя голубым шаром, мы берём его со стола и кладём в корзинку `push(Blue):true`. _Да-да, у англичан предпоследний цвет радуги называется Indigo, а голубой не рифмуется с гомо-._ Теперь в коробке лежит один шар, но в воображении он же остался и перед нами, перед коробкой, потому что само понятие состояния, которое символизирует шар, никуда не девается от того, что мы наполняем им корзинку. Мы можем повторить действие, снова взять голубой шар и ещё раз положить его в корзинку `push(Blue):false`, но от этого действия сейчас ничего не изменится, о чём нам говорит возвращаемый методом отрицательный ответ `false` — команда выполнена, но состояние корзинки не изменилось. То есть перед нами постоянно лежат семь шаров, а в корзинке сейчас по прежнему лежит один голубой шар. Конечно, в каждой конкретной задаче число шаров будет разным. Допустим после ряда совершённых операций нам нужно отметить их тремя флагами. Для этого достаточно одной операции: положить в корзинку зелёный, голубой и фиолетовый шары `push(Green|Blue|Violet):true`. Голубой шар в корзинке уже лежал, теперь в ней лежат три шара.

В корзинке лежат зелёный, голубой и фиолетовый шары. Следующая операция требует проверить, есть ли в корзинке какой-то шар среди красного, жёлтого и зелёного цвета. Для этого тоже хватит одной операции: заглянем в корзинку и посмотрим, есть ли в ней искомые шары `exist(Orange|Yellow|Green):true`. Т.к. в корзинке лежит зелёный шар, то ответ «Да», о чём говорит положительный ответ `true` метода проверки. Далее, в случае наличия определённых флагов нам нужно выполнить дополнительное действие, т.е. пусть если в корзинке лежат голубой, синий и фиолетовый шары, то операцию нужно выполнить. Смотрим в корзинку и проверяем, есть ли в ней все эти шары `if every(Blue|Indigo|Violet):false`. В нашей корзинке лежат три шарика, но синего мы в неё не клали, значит ответ будет ложный `false` и действие выполнять не нужно. Ещё можно проверить отсутствие одного или нескольких указанных шаров. Проверим, что среди красного, оранжевого и жёлтого шаров в корзинке нет ни одного `empty(Red|Orange|Yellow):false` — ответ отрицательный, потому что указанное множество шаров в корзинке не пустое, красный и жёлтый шары в ней лежат. Результат метода `empty` всегда противоположен результату метода `exist`, но не методу `every`. Метод `exist` проверяет флаги по OR (один из указанных), а методы `empty` и `every` — по AND (все указанные). Именно для удобства запоминания названия этих трёх методов подобраны похожими, они начинаются с одинаковой буквы и имеют длину в пять букв.

В корзинке лежат зелёный, голубой и фиолетовый шары. После выполнения некоторой операции мы освободили ресурсы и хотим отметить это. Заберём из корзинки два шарика, жёлтый и зелёный, `take(Yellow|Green):true`. Не смотря на то, что каких-то шаров в корзинке может не быть, мы всё равно можем их штатно извлекать, просто их как не было в корзинке, так и не будет. Операция возвращает позитивный ответ `true`, т.к. состояние корзинки изменилось, в ней больше нет зелёного шара. Теперь разом поменяем часть шаров на другие, заберём голубой и синий, а добавим красный `swap(Blue|Indigo, Red):true`. Это всё тоже можно выполнять в одно комбинированное действие, оно чуть быстрее, чем отдельно забрать, а потом положить шары, но по смыслу соответствует именно такому порядку, если нам взбредёт в голову забирать и класть один и тот же шарик — в итоге шарик будет лежать в корзинке.

В корзинке лежат красный и фиолетовый шары. Операция переворота нужна для работы с состояниями и перечислениями, о них написано ниже, но её можно использовать и с простыми шариками. Поменяем состояние красного, оранжевого и жёлтого шариков так, чтобы они лежали в корзинке `turn(Red|Orange|Yellow, true):true` — корзинка поменялась, красный шар уже был, оранжевый и жёлтый появились, фиолетовый не добавлялся, но тоже был. Теперь сделаем так, чтобы среди красного, оранжевого, жёлтого и голубого шаров в корзинке были только красный и жёлтый `turn(Red|Orange|Yellow|Blue, Red,Yellow):true` — ответ положительный, корзинка снова поменялась, красный остался, оранжевый убран, жёлтый добавлен, голубого и не было, а зелёный и фиолетовый шары в корзинке не трогали.

В корзинке лежат красный, жёлтый, зелёный и фиолетовый шары. Есть ещё несколько проверочных действий, которые можно выполнять с простыми шариками. Проверим, что среди красного, оранжевого и жёлтого шаров в корзинке лежат только красный и жёлтый, не обращая внимания на лежащие в ней зелёный и другие `every(Red|Orange|Yellow, Red|Yellow):true` — ответ положительный, т.к. красный и жёлтый шары в корзинке есть, а оранжевого нет. Подобную проверку сформулируем иначе, чтобы оранжевого шара не было, а красный и жёлтый были `state(Orange, Red|Yellow):true` — ответ положительный. Есть особый метод позволяющий получить не простой ответ, а набор шаров, при этом состояние корзинки метод не меняет, запросим какие шары есть среди красного, зелёного и синего `mask(Red|Green|Indigo):Red|Green` — такой ответ в виде маски можно дополнительно разобрать оператором `switch`.

### Реализация

Первый пример предполагает однопоточное использование объекта с корзинкой. Для поддержки многопоточности и синхронизации изменения флагов нужно наследовать класс `ABasketSync` и грамотно использовать синхронные методы. 

Сначала создаём класс и наследуем его от `ABasket`, защищённо (protected) предоставляющего все необходимые методы для работы с корзинкой. Затем в коде, рекомендуется в самом в конце класса, нужно объявить константы, которые в виде маски будут хранить позицию одного или нескольких значащих бит в корзинке. Эти константы и будут флагами или воображаемыми шарами (см. выше), а значения в корзинке — состояниями этоих флагов. Константы финального класса можно указывать с нулевого бита и выше до уже занятых, но если корзинка будет использоваться в классах наследниках, то нужно соблюдать правило резервирования бит через константу границы `fin` от старших к младшим. Сама корзинка предоставляет разработчику 31 бит (30..0), самый старший используется для синхронизации.

~~~ java
class Sample extends ABasket {

  /* { code of constructor and methods } */

//protected static final int fin = ABasket.fin-8;

  private static final int Red    = 1<<0; // Один бит в нулевой позиции
  private static final int Orange = 1<<1; // Один бит в первой позиции
  private static final int Yellow = 1<<2;
  private static final int Green  = 1<<3;
  private static final int Blue   = 1<<4;
  private static final int Indigo = 1<<5;
  private static final int Violet = 1<<6;

  private static final int mHot  = Red|Orange|Yellow;  // Маска тёплых цветов
  private static final int mCold = Blue|Indigo|Violet; // Маска холодных цветов
}
~~~

Далее, следуя аналогии описанной в предыдущем разделе, мы можем класть флаги в корзинку, извлекать, обменивать и проверять их наличие. Забегая вперёд, если соблюдены правила объявления констант, то при отладке набор флагов лежащий сейчас в корзинке можно посмотреть функцией `Basket.toString(instance)`.

## Пример

Ниже приведён надуманный, но относительно жизненный пример реального использования корзинки. Класс `SpecialConnection` тоже выдуманный и приведён без реализации, его суть в простом поддержании активного соединения и соблюдении целостности ответа.

_(TODO: код не проверял, нет под рукой IDE. Проверить на ошибки!)_

~~~ java
class Sample extends ABasket implements Closable {
  private SpecialConnection helper;
  private String            host, path;
  private StringBuffer      request = new StringBuffer(256);
  private int               lengthPosition, bodyPosition;

  /** Инициализировать параметры соединения */
  public void initialize(String host, String path) {
    // Сначала кладём флаг Initialized в корзинку и получаем результат. Если результат
    // отрицательный, значит флаг уже лежал и адрес уже был задан.
    if (!push(Initialized)) throw new IllegalInitializeException();
    this.host = host;
    this.path = path;
  }

  /** Сбросить параметры соединения и само соединение, если оно активно */
  public void reset(String host, String path) {
    if (exist(Closed     )) throw new ClosedException(); // Объект уже закрыт
    if (empty(Initialized)) return;                      // Инициализации и так нет
    if (exist(Connected  )) helper.disconnect();         // Есть соединение, разорвать
    if (exist(Header     )) request.clear();             // Есть часть запроса, очистить
    // Забираем все флаги, наличие Closed здесь невозможно
    take(mStatus|Connected);
  }

  /** Добавить заголовок к запросу */
  public void header(String header) {
    // Разом проверяем шесть проблем и если их нет, то пропускаем решение проблем
    // Из шести основных состояний активны должны быть только Initialized и Header
    if (!every(mStatus, Initialized|Header)) { // Если нет нужного набора состояний, то...
      // Если состояние одно из пяти недопустимых, то создать и выбросить исключение
      if (!state(Request|Error|Body|Closed, Initialized))
        // Если Body нет, то проблема типичная, иначе проблема с Body
        throw empty(Body) ? TypicalError() : new CantWriteHeaderAfterBodyException();

      // Раз других проблем нет, то остался только Header, открыть его и положить флаг
      request.append("GET ").append(path).append(" HTTP/1.0\nHost: ").append(host)
            .append("\nContent-Length: ");
      lengthPosition = request.size();
      request.append("         \nConnection: keep-alive\n");
      push(Header);
    }

    // Добавить указанный в аргументе заголовок
    request.append(header).append('\n');
  }

  /** Добавить часть тела к запросу */
  public void body(String body) {
    // Разом проверяем пять проблем и если их нет, то пропускаем решение проблем
    if (!every(mStatus, Initialized|Header|Body)) { // Если нет нужного набора состояний, то...
      // Если проблема одна из четырёх основных, то определить её и выбросить исключение
      if (!state(Request|Error|Closed, Initialized)) throw TypicalError();

      // Раз критический проблем нет, то решаем оставшиеся две
      if (empty(Header)) header("");
      else if (empty(Body)) request.append('\n');
      bodyPosition = request.size();
      push(Body);
    }

    // Добавить часть тела в запрос
    request.append(body);
  }

  /** Отправить запрос на сервер */
  public void request() {
    // Если один из четырёх важных флагов в недопустимом положении, выбросить исключение
    if (!state(Request|Error|Closed, Initialized)) throw TypicalError();

    // Добавить флаг Connection. Если этого флага не было, то создать соединение
    if (push(Connected)) {
      if (helper == null) helper = new SpecialConnection(host);
      helper.connect();
    }

    // Пишем заголовок если его нет, вычисляем длину тела, если оно есть
    int bodyLength = 0;
    if (empty(Header)) header("");
    else if (exist(Body)) length = request.size() - bodyPosition;

    // Пишем в заголовок длину тела
    if (bodyLength > 999999999) { push(Error); throw new OverflowBodySizeException() }
    request.replace(lengthPosition, Integer.toString(bodyLength));

    // Отправляем запрос через вспомогательный объект соединения
    helper.request(request.toString());
    request.clear();
    // Меняем флаги: Header и Body забираем, т.к. очистили буфер запроса,
    swap(Header|Body, Request); // ...а Request кладём, т.к. запрос был отправлен
  }

  /** Получить ответ от сервера */
  public String response() {
    // Если один из четырёх важных флагов в недопустимом положении, выбросить исключение
    if (!state(Error|Closed, Initialized)) throw TypicalError();
    if (empty(Request)) throw new RequestIsNotActiveException();

    try { return helper.readResponse(); }
    catch (Exception ex) { push(Error); }
    finally { take(Request); }
  }

  /** Завершить работу объекта и запретить его дальнейшее использование */
  public void close() {
    reset();
    if (helper != null) helper.close(); // Закрыть соединение, если оно есть
    push(Initialized|Closed); // Ставим ещё и Initialized, чтобы не проверять его в инициализаторе
  }

  private Exception TypicalError() {
    if (empty(Initialized)) return new NotInitializedException();
    if (exist(Closed     )) return new ClosedException();
    if (exist(Request    )) return new RequestIsActiveException();
    return new InternalErrorException();
  }


//======== Basket : работа с корзинкой флагов ============================================//
  private String debugBasket() { return Basket.toString(this); } 

  /** Объявление границы для отладки (первый свободный для наследника бит)*/
  protected static final int fin = ABasket.fin-8;

  /** Инициализация выполнена, адрес задан */
  private static final int Initialized = 1<<fin+1;
  /** Многоразовое соединение с сервером установлено */
  private static final int Connected   = 1<<fin+2;
  /** Запись заголовка запроса */
  private static final int Header      = 1<<fin+3;
  /** Запись тела запроса */
  private static final int Body        = 1<<fin+4;
  /** Запрос серверу отправлен, ожидается ответ */
  private static final int Request     = 1<<fin+5;
  /** Произошла ошибка */
  private static final int Error       = 1<<fin+6;
  /** Работа завершена */
  private static final int Closed      = 1<<fin+7;

  /** Маска из шести основных часто проверяемых состояний */
  private static final int mStatus = Initialized|Header|Body|Request|Error|Closed;
//^^^^^^^^ Basket : работа с корзинкой флагов ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^//
}
~~~

### Неочевидные возможности

Корзинок в одном объекте может быть несколько. Это не очень удобно реализуется в Java (легко в C++), но вполне возможно. Пример реализации можно увидеть классе в `Conveyor/Plan`.

Корзинка позволяет реализовать несколько независимых блокировок в одном классе без создания каких-либо объектов. К тому же можно захватывать несколько блокировок одновременно. Для этого нужно включать синхронизацию или захват с дополнительным одним или несколькими флагами, которые в таком режиме считаются мониторами или mutex'ами.

## Простая работа с флагами

_(асинхронные методы изменения и проверки флагов)_

Для работы с флагами без синхронизации достаточно наследовать свой класс от `ABasket`.

**Методы изменения состояния флагов в корзинке:**

* `bool push(int mask)` — установить (положить) флаги по маске. Если флаг уже есть, он там и останется. Возвращает признак, изменилось ли состояние корзинки.
* `bool take(int mask)` — снять (забрать) флаги по маске. Если флага нет, он забран не будет. Возвращает признак, изменилось ли состояние корзинки.
* `bool swap(int takeMask, int pushMask)` — снять одни флаги и установить другие указанные в масках. Аналогичен вызову двух методов подряд: `#take(int)` и `#push(int)`. Возвращает признак, изменилось ли состояние корзинки.
* `bool turn(int mask, bool state)` — установить флаги по маске в состояние, указанное в state. Меняет в корзинке все флаги, которые отмечены параметром `mask` на значение указанное в параметре `state`. Возвращает признак, изменилось ли состояние корзинки.
* `bool turn(int mask, int model)` — установить флаги по маске в соответствии с моделью. Меняет в корзинке все флаги, которые отмечены параметром `mask` на те значения, которые указаны в параметре `model`. Возвращает признак, изменилось ли состояние корзинки.

**Методы проверки состояния флагов в корзинке:**

* `bool exist(int mask)` — проверить наличие любого флага из указанных в маске.
* `bool empty(int mask)` — проверить отсутствие всех флагов указанных в маске.
* `bool every(int mask)` — проверить наличие всех флагов указанных в маске.
* `bool every(int mask, int model)` — сверить совпадение состояния всех флагов указанных в маске с состоянием в модели.
* `bool state(int emptyMask, int everyMask)` — проверить строгое отсутствие всех флагов из emptyMask и наличие из everyMask.
* `int mask(int mask)` — возвращает флаги отфильтрованные по указанной маске.

## Синхронная работа с флагами

_(синхронные аналоги)_

## Перечисления (аналог enum)

_(способы записи групп флагов и их проверки, предполагая их предопределёнными состояниями)_

## Упаковка малых беззнаковых чисел

_(методы упаковки и распаковки чисел в корзинку)_

## Синхронизация потоков (опасная)

_(не забыть описать опасность двойной блокировки или неаккуратной ложной разблокировки)_
